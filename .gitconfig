[user]
	name = nskazki
	email = nskazki@gmail.com

[core]
	autocrlf = input
	safecrlf = true

[alias]
  alias-list = "!f() { \
    git config --list \
    | grep alias \
    | grep -v -P ^alias.alias \
    | grep -v -P ^alias.cmd- \
    | sed -e s/=.*// \
    | grep - \
    | sort; \
  }; f"

  type = cat-file -t
  dump = cat-file -p

  # external-scripts
  script-wtf         = "!~/.git-tools/git-wtf"
  script-show-merges = "!~/.git-tools/git-show-merges"
  script-server      = "!~/.git-tools/git-server"
  script-contributors-debug = "!~/.git-tools/git-contributors-debug"

  # notes
  note-reset = "!f() { \
    echo 'git reflog';\
    echo 'git reset --hard HEAD@{0}';\
  }; f"

  # base
  cmd-uncommit = "!f() { \
    rm -f \"$(git git-dir)/.uncommit_cnt\"; \
    git log -1 --pretty=%B > \"$(git git-dir)/.uncommit_msg\"; \
    git reset --soft HEAD^; \
  }; f"

  uncommit = !"git cmd-uncommit"
  recommit = "commit --amend"
  unstage = "reset HEAD"

  # root
  root = "rev-parse --show-toplevel"

  # git-dir
  git-dir = "rev-parse --git-dir"

  # push-branch
  pushb       = !"git cmd-push-branch"
  push-branch = !"git cmd-push-branch"

  cmd-push-branch = "!f() { \
    local branch=\"$(test \"$1\" && echo \"$1\" || echo \"$(git branch-name)\")\"; \
    local remote=\"$(test \"$2\" && echo \"$2\" || echo \"$(git remote | head -n 1)\")\"; \
    local remote_branch_exist=\"$(git show-branch \"remotes/$remote/$branch\" 2>/dev/null)\"; \
    local junk_cmp_branch=\"$(test \"$remote_branch_exist\" && echo \"$remote/$branch\" || echo master)\"; \
    local junk_exist=\"$(git log \"$junk_cmp_branch..$branch\" --pretty=format:'%s' | grep -P '^\\s*\\d+\\s*$|^\\s*tod|^\\s*tos|^\\s*fixup')\"; \
    test -n \"$junk_exist\" && echo \"cleanup junk first: $junk_exist\" && return 1; \
    echo $branch '->' $remote; \
    git push -u $remote $branch --tags; \
  }; f"

  # pull-branch
  pullb       = !"git cmd-pull-branch"
  pull-branch = !"git cmd-pull-branch"

  cmd-pull-branch = "!f() { \
    local branch=\"$(test \"$1\" && echo \"$1\" || echo $(git branch-name))\"; \
    local remote=\"$(test \"$2\" && echo \"$2\" || echo $(git remote | head -n 1))\"; \
    echo $branch '<-' $remote; \
    git branch -u $remote/$branch; \
    git pull $remote $branch; \
  }; f"

  # pull-all
  pull-all = !"git cmd-pull-all"
  cmd-pull-all = "!f() { \
    git branch -r | grep -v '\\->' | while read remote; do git branch --track \"${remote#origin/}\" \"$remote\"; done; \
    git fetch --all; \
    git pull --all; \
  }; f"

  # recursive
  cmd-clone-recursive = "clone --recursive"
  clone-recursive = !"git cmd-clone-recursive"

  # tag-delete
  tag-delete = !"git cmd-tag-delete"
  cmd-tag-delete = "!f() { \
    if [ -z \"$1\" ]; then \
      echo \"usage: git tag-delete <tag-name>\"; \
      return 1; \
    fi; \
    local tag=\"$1\"; \
    echo \"delete: $tag\"; \
    if [ $(git prompt) -eq 0 ]; then \
      echo -n \"local: \"; \
      git tag -d $tag; \
      echo -n \"origin: \"; \
      git push origin :refs/tags/$tag; \
    fi; \
  }; f"

  # branch-delete
  branch-delete = !"git cmd-branch-delete"
  cmd-branch-delete = "!f() { \
    if [ -z \"$1\" ]; then \
      echo \"usage: git branchd <branch-name>\"; \
      return 1; \
    fi; \
    local branch=\"$1\"; \
    echo \"delete: $branch\"; \
    if [ $(git prompt) -eq 0 ]; then \
      echo -n \"local: \"; \
      git branch -D $branch; \
      echo -n \"origin: \"; \
      git push origin --delete $branch; \
    fi; \
  }; f"

  prompt = "!f() { \
    read -r -p 'Are you sure? [y/N] ' response; \
    case $response in \
      [yY][eE][sS]|[yY]) \
        echo 0; \
        return 0; \
      ;; \
      *) \
        echo 1; \
        return 1; \
      ;; \
    esac \
  }; f"

  # logs
  cmd-log-hist = "!git log --graph --color=always --date=format:'%Y-%m-%d %H:%M' --format='%C(magenta)%h %C(blue)%ad %C(green)%an %C(reset)%s%C(auto)%d%C(reset)'"
  cmd-log-last = "!git --no-pager cmd-log-hist -n 10"

  l        = !"git cmd-log-last"
  log-last = !"git cmd-log-last"
  log-hist = !"git cmd-log-hist"

  # Show verbose output about tags, branches or remotes
  cmd-branch-verbose = "branch -av"
  cmd-remote-verbose = "remote -v"

  branch-verbose = !"git cmd-branch-verbose"
  remote-verbose = !"git cmd-remote-verbose"

  # rebase
  cmd-rebase-by       = "!r() { git rebase -i HEAD~$1; }; r"

  rebase-by       = !"git cmd-rebase-by"

  # gitignore [git cmd <path>]
  cmd-gitignore-reset-all = "!git rm -r --cached . && git add ."
  cmd-gitignore-print-all = "!f() { git ls-files --other --ignored --exclude-standard $@ | grep -v node_modules; }; f"

  gitignore-reset = !"git cmd-gitignore-reset-all"
  gitignore-print = !"git cmd-gitignore-print-all"

  # status
  cmd-status-short = "status -s"

  ss           = !"git status"
  s            = !"git cmd-status-short"
  status-short = !"git cmd-status-short"

  # diff
  cmd-diff-staged = "!git diff --staged"

  d           = !"git diff"
  ds          = !"git cmd-diff-staged"
  diff-staged = !"git cmd-diff-staged"

  # view-commit
  cmd-view-commit = "!f() {\
    local commit=\"$(test \"$1\" && echo \"$1\" || echo \"HEAD\")\"; \
    (git show --color=always --stat="$(tput cols)" --pretty=fuller $commit && echo && git diff --color=always $commit^..$commit) | less; \
  }; f"

  vv          = !"git cmd-view-commit"
  view-commit = !"git cmd-view-commit"

  # view-commit-head
  cmd-view-commit-head = "!f() {\
    local commit=\"$(test \"$1\" && echo \"$1\" || echo \"HEAD\")\"; \
    git show --color=always --stat="$(tput cols)" --pretty=fuller $commit; \
  }; f"

  v                = !"git cmd-view-commit-head"
  view-commit-head = !"git cmd-view-commit-head"

  # branch
  cmd-branch-name   = "!git rev-parse --abbrev-ref HEAD"
  cmd-branch-rename = "!f() { \
    local rename=\"$(test \"$2\" && echo \"$2\" || echo \"$1\")\"; \
    local branch=\"$(test \"$2\" && echo \"$1\" || echo $(git branch-name))\"; \
    echo $branch '->' $rename; \
    git branch -m $branch $rename; \
  }; f"

  branch-name   = !"git cmd-branch-name"
  branch-rename = !"git cmd-branch-rename"

  # config
  config-bare = "!git config --bool core.bare true"
  config-show = "!git config --list --local"

[apply]
  # Detect whitespace errors when applying a patch
  whitespace = fix

[core]
  # Treat spaces before tabs and all kinds of trailing whitespace as an error
  # [default] trailing-space: looks for spaces at the end of a line
  # [default] space-before-tab: looks for spaces before tabs at the beginning of a line
  whitespace = space-before-tab,-indent-with-non-tab,trailing-space
  # Make `git rebase` safer on OS X
  # More info: <http://www.git-tower.com/blog/make-git-rebase-safe-on-osx/>
  trustctime = false
  # Prevent showing files whose names contain non-ASCII symbols as unversioned.
  # http://michael-kuehnel.de/git/2014/11/21/git-mac-osx-and-german-umlaute.html
  precomposeunicode = false
  # Edge version of nano
  editor = /usr/bin/env nano

[color]
  # Use colors in Git commands that are capable of colored output when
  # outputting to the terminal. (This is the default setting in Git â‰¥ 1.8.4.)
  ui = auto

[color "branch"]
  current = yellow reverse
  local = yellow
  remote = green

[color "diff"]
  meta = yellow bold
  frag = magenta bold # line info
  old = red # deletions
  new = green # additions

[color "status"]
  added = yellow
  changed = green
  untracked = cyan

[diff]
  # Detect copies as well as renames
  renames = copies
	tool = meld

# [help]
  # Automatically correct and execute mistyped commands
  # autocorrect = 1

[merge]
  # Include summaries of merged commits in newly created merge commit messages
  log = true

[merge]
  conflictstyle = diff3

[merge]
  tool = smerge

[mergetool "meld_diff3"]
  cmd = 'meld "$LOCAL" "$BASE" & sleep 0.5 && meld "$BASE" "$REMOTE" & sleep 0.5 && meld "$LOCAL" "$MERGED" "$REMOTE" &'

[mergetool "smerge"]
  cmd = 'smerge mergetool "$BASE" "$LOCAL" "$REMOTE" -o "$MERGED"'
  trustExitCode = true

[push]
  # Use the Git 1.x.x default to avoid errors on machines with old Git
  # installations. To use `simple` instead, add this to your `~/.extra` file:
  # `git config --global push.default simple`. See http://git.io/mMah-w.
  default = simple
  # Make `git push` push relevant annotated tags when pushing branches out.
  followTags = true

[url "git@github.com:"]
  insteadOf = "gh:"
  pushInsteadOf = "github:"
  pushInsteadOf = "git://github.com/"

[url "git://github.com/"]
  insteadOf = "github:"

[url "git@gist.github.com:"]
  insteadOf = "gst:"
  pushInsteadOf = "gist:"
  pushInsteadOf = "git://gist.github.com/"

[url "git://gist.github.com/"]
  insteadOf = "gist:"

[url "https://"]
  insteadOf = git://

[stash]
  showPatch = true

[rebase]
  autostash = true
  autosquash = true

[commit]
  verbose = true
