#! /usr/bin/env bash

# !git-tools
alias got='git'
alias gut='git'
alias get='git'
alias gti='git'

function g {
  if [[ -z $1 ]]; then tig
  else git $@; fi
}

alias t='tig'
alias b='tig blame'
alias y='tig stash'

alias v='git view-last-commit'
alias l='git log-last'
alias s='git status-short'
alias ss='git status'
alias d='git diff'
alias ds='git diff-staged'

bash_setup="\
  set -e && \
  export PATH=$PATH:/home/nskazki/.fzf/bin && \
  source $HOME/.bash-tools/bash.git && \
  source $HOME/.bash-tools/bash-aliases && \
  source $HOME/.bash-tools/bash-clr && \
  source $HOME/.bash-tools/fzf.git && \
  source $HOME/.bash-tools/fzf.bash "

function rb {
  bash -c "$bash_setup && git-rebase-smart $@"
  return $?
}

function rc {
  bash -c "$bash_setup && git-recommit-smart $@"
  return $?
}

function rt {
  bash -c "$bash_setup && git-squash-tmp-smart $@"
  return $?
}

function rf {
  bash -c "$bash_setup && git-last-tmp-to-fixup-smart $@"
  return $?
}

function c {
  bash -c "$bash_setup && git-commit-tmp $@"
  return $?
}

function m {
  bash -c "$bash_setup && git-commit-smart $@"
  return $?
}

function f {
  bash -c "$bash_setup && git-commit-fixup-smart $@"
  return $?
}

function u {
  bash -c "$bash_setup && git-unstage-smart $@"
  return $?
}

function a {
  bash -c "$bash_setup && git-add-smart $@"
  return $?
}

function r {
  bash -c "$bash_setup && git-remove-untracked-smart $@"
  return $?
}

alias rt.='rt .'
alias rc.='rc .'
alias rf.='rf .'
alias p.='a -p'
alias c.='c .'
alias m.='m .'
alias f.='f .'
alias u.='u .'
alias a.='a .'
alias r.='r .'

alias rt,='rt .'
alias rc,='rc .'
alias rf,='rf .'
alias p,='a -p'
alias c,='c .'
alias m,='m .'
alias f,='f .'
alias u,='u .'
alias a,='a .'
alias r,='r .'

function git-not-has-staged {
  local git_ss="$(git status -s)"
  local modified_staged=$(echo "$git_ss" | grep -c -s -P '^M')
  local renamed=$(echo "$git_ss" | grep -c -s -P '^R')
  local added_staged=$(echo "$git_ss" | grep -c -s -P '^A')
  local deleted_staged=$(echo "$git_ss" | grep -c -s -P '^D')
  if [ $modified_staged -eq 0 ] && [ $renamed -eq 0 ] && [ $added_staged -eq 0 ] && [ $deleted_staged -eq 0 ]; then
    return 0
  else
    return 1
  fi
}

function git-not-has-unstaged {
  local git_ss="$(git status -s)"
  local modified_notstaged=$(echo "$git_ss" | grep -c -s -P '^.M')
  local added_notstaged=$(echo "$git_ss" | grep -c -s -P '^\?\?')
  local deleted_notstaged=$(echo "$git_ss" | grep -c -s -P '^.D')
  local unmerged=$(echo "$git_ss" | grep -c -s -P '^(.U|U.)')
  if [ $modified_notstaged -eq 0 ] && [ $added_notstaged -eq 0 ] && [ $deleted_notstaged -eq 0 ] && [ $unmerged -eq 0 ]; then
    return 0
  else
    return 1
  fi
}

function git-not-has-changes {
  local git_ss="$(git status -s)"
  if [[ -z "$git_ss" ]]; then
    return 0
  else
    return 1
  fi
}

function git-find-first-tmp {
  git log --format="%h %s" -n 100 | while read line ; do
    if [[ -n "$(echo "$line" | grep -P '^\w+\s\d+$')" ]]; then
      local last="$line"
      else
      echo "$last" | sed -r -e 's/\s+[0-9]+//'
      break
    fi
  done
}

function __git-add-fzf__ {
  local files="$(gf)"
  if [[ -n "$files" ]]; then
    echo "$files" | while read line ; do
      git add "$line"
    done
  else
    exit 130
  fi
}

function __git-unstage-fzf__ {
  local files="$(gf)"
  if [[ -n "$files" ]]; then
    echo "$files" | while read line ; do
      git unstage "$line"
    done
  else
    exit 130
  fi
}

function __git-rebase-fzf__ {
  local commit="$(gh)"
  if [[ -n "$commit" ]]; then
    git rebase -i "$commit^"
  else
    exit 130
  fi
}

function __git-fixup-fzf__ {
  local commit="$(gh)"
  if [[ -n "$commit" ]]; then
    git commit --fixup "$commit"
  else
    exit 130
  fi
}

function git-recommit-smart {
  if $(git-not-has-changes); then
    git recommit
    git show --stat HEAD
  else
    if [[ "$1" == '.' ]]; then
      git add .
    fi
    if $(git-not-has-staged); then
      __git-add-fzf__
    fi

    git recommit
    git show --stat HEAD
  fi
}

function git-rebase-smart {
  if $(git-not-has-changes); then
    __git-rebase-fzf__
    git log-last
  else
    git status
    clr_bg_red "cleanup project first!"
    exit 3
  fi
}

function git-commit-tmp {
  if $(git-not-has-changes); then
    clr_yellow_b "nothing to do!"
    exit 2
  else
    if [[ "$1" == '.' ]]; then
      git add .
    fi
    if $(git-not-has-staged); then
      git add .
    fi

    git status

    local last=$(git log --format=%B -n 1 HEAD | rg '^[0-9]+$')
    if [[ -n "$last" ]]; then
      local next="$(expr $last + 1)"
      git commit -m "$next"
      echo && git log-last
    else
      local first="1"
      git commit -m "$first"
      echo && git log-last
    fi
  fi
}

function git-commit-smart {
  if $(git-not-has-changes); then
    clr_yellow_b "nothing to do!"
    exit 2
  else
    if [[ "$1" == '.' ]]; then
      git add .
    fi
    if $(git-not-has-staged); then
      __git-add-fzf__
    fi

    git status

    if [[ "$1" == '.' ]]; then
      git commit
    elif [[ -z "$1" ]]; then
      git commit
    else
      local summ
      for n in $@; do
        summ="$summ $n"
      done
      local trimmed="$(trim "$summ")"
      git commit -m "$trimmed"
    fi
  fi
}

function git-commit-fixup-smart {
  if $(git-not-has-changes); then
    clr_yellow_b "nothing to do!"
    exit 2
  else
    if [[ "$1" == "." ]]; then
      git add .
    fi
    if $(git-not-has-staged); then
      __git-add-fzf__
    fi

    git status

    if [[ "$1" == "." ]]; then
      git commit --fixup HEAD
      echo && git log-last
    elif [[ -n "$1" ]]; then
      git commit --fixup $@
      echo && git log-last
    else
      __git-fixup-fzf__
      echo && git log-last
    fi
  fi
}

function git-unstage-smart {
  if $(git-not-has-staged); then
    clr_yellow_b "nothing to do!"
    exit 2
  else
    if [[ -n "$1" ]]; then
      git unstage $@
      git status
    else
      __git-unstage-fzf__
      git status
    fi
  fi
}

function git-add-smart {
  if $(git-not-has-unstaged); then
    clr_yellow_b "nothing to do!"
    exit 2
  else
    if [[ -n "$1" ]]; then
      git add $@
      git status
    else
      __git-add-fzf__
      git status
    fi
  fi
}

function git-remove-untracked-smart {
  local git_ss="$(git status -s)"
  local added_notstaged=$(echo "$git_ss" | grep -c -s -P '^\?\?')

  if [[ "$added_notstaged" -eq 0 ]]; then
    clr_yellow_b "nothing to do!"
    exit 2
  elif [[ "$1" == '.' ]]; then
    local all="$(git status -s | grep "??" | sed -e "s/?? //")"
    clr_red_i "$all"
    echo
    echo "$all" | while read line ; do
      gvfs-trash -f "$line"
    done
    git status
  else
    local all="$(git status -s | grep "??" | sed -e "s/?? //")"
    local trash="$(echo "$all" | fzf --reverse --multi --ansi --preview-window right:70% \
      --bind 'ctrl-k:preview-up' \
      --bind 'ctrl-j:preview-down' \
      --preview '((echo $(basename {}) | grep .svg > /dev/null 2>&1 && rsvg {} tmp/preview.png && img2txt tmp/preview.png) \
                   || (file --mime {} | grep image > /dev/null 2>&1 && img2txt {}) \
                   || (file --mime {} | grep binary > /dev/null 2>&1 && echo {} is a binary file) \
                   || (highlight -O ansi -l {} || coderay {} || cat {})) 2> /dev/null | head -500')"
    if [[ -n "$trash" ]]; then
      clr_red_i "$trash"
      echo
      echo "$trash" | while read line ; do
        gvfs-trash -f "$line"
      done
      git status
    fi
  fi
}

function git-squash-tmp-smart {
  if $(git-not-has-changes); then
    if [[ "$1" == '.' ]]; then
      local commit="$(git-find-first-tmp)"
      if [[ -n "$commit" ]]; then
        GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/script-squash-tmp.js" git rebase -i "$commit"^
        git show --stat HEAD
      else
        clr_yellow_b "nothing to do"
        git log-last
        exit 2
      fi
    else
      local commit="$(gh)"
      if [[ -n "$commit" ]]; then
        GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/script-squash-tmp.js" git rebase -i "$commit"^
        git show --stat HEAD
      else
        exit 130
      fi
    fi
  else
    git status
    clr_bg_red "cleanup project first!"
    exit 3
  fi
}

function git-last-tmp-to-fixup-smart {
  if $(git-not-has-changes); then
    local log="$(git log --format="%h %s" -n1)"
    if [[ -n "$(echo "$log" | grep -P '^\w+\s\d+$')" ]]; then
      git uncommit
      git-commit-fixup-smart $@
    else
      git log-last
      clr_bg_red "last commit is not temporary!"
    fi
  else
    git status
    clr_bg_red "cleanup project first!"
    exit 3
  fi
}
