#! /usr/bin/env bash

# !git-tools
alias got='git'
alias gut='git'
alias get='git'
alias gti='git'

function g {
  if [[ -z $1 ]]; then
    tig
  elif [[ -f "$(resolve "$1")" ]]; then
    tig $@
  elif [[ -n "$(echo "$1" | grep -P '[\w-/]+\.{2,3}[\w-/]+')" ]]; then
    tig $@
  else
    git $@
  fi
}

alias t='tig'
alias b='tig blame'
alias y='tig stash'

alias v='git view-last-commit'
alias l='git log-last'
alias s='git status-short'
alias ss='git status'
alias d='git diff'
alias ds='git diff-staged'

alias rb='git-rebase-smart'
alias rc='git-recommit-smart'
alias rt='git-squash-tmp-smart'
alias rf='git-last-tmp-to-fixup-smart'
alias c='git-commit-tmp'
alias m='git-commit-smart'
alias f='git-commit-fixup-smart'
alias u='git-unstage-smart'
alias a='git-add-smart'
alias r='git-remove-untracked-smart'

alias rb.='rb .'
alias rc.='rc .'
alias rt.='rt .'
alias rf.='rf .'
alias c.='c .'
alias m.='m .'
alias f.='f .'
alias u.='u .'
alias a.='a .'
alias r.='r .'
alias p.='a -p'

alias rb,='rb .'
alias rc,='rc .'
alias rt,='rt .'
alias rf,='rf .'
alias c,='c .'
alias m,='m .'
alias f,='f .'
alias u,='u .'
alias a,='a .'
alias r,='r .'
alias p,='a -p'

alias __exit-on-error__='local last=$?; test $last -ne 0 && return $last'
alias __memoize-error__='local last=$?; test $last -ne 0 && __git-smart-set-error__ $last'
alias __print-on-error__='local last=$?; test $last -ne 0 && echo && clr_bg_red "return $last"'

function __git-smart-get-error__ {
  cat "$HOME/.git-smart-error"
}

function __git-smart-del-error__ {
  echo 0 > "$HOME/.git-smart-error"
}

function __git-smart-set-error__ {
  if [[ -n "$1" ]]; then
    local error="$1"
  else
    local error="1"
  fi
  echo "$error" > "$HOME/.git-smart-error"
}

function git-not-has-staged {
  local git_ss="$(git status -s)"
  local modified_staged=$(echo "$git_ss" | grep -c -s -P '^M')
  local renamed=$(echo "$git_ss" | grep -c -s -P '^R')
  local added_staged=$(echo "$git_ss" | grep -c -s -P '^A')
  local deleted_staged=$(echo "$git_ss" | grep -c -s -P '^D')
  if [ $modified_staged -eq 0 ] && [ $renamed -eq 0 ] && [ $added_staged -eq 0 ] && [ $deleted_staged -eq 0 ]; then
    return 0
  else
    return 1
  fi
}

function git-not-has-unstaged {
  local git_ss="$(git status -s)"
  local modified_notstaged=$(echo "$git_ss" | grep -c -s -P '^.M')
  local added_notstaged=$(echo "$git_ss" | grep -c -s -P '^\?\?')
  local deleted_notstaged=$(echo "$git_ss" | grep -c -s -P '^.D')
  local unmerged=$(echo "$git_ss" | grep -c -s -P '^(.U|U.)')
  if [ $modified_notstaged -eq 0 ] && [ $added_notstaged -eq 0 ] && [ $deleted_notstaged -eq 0 ] && [ $unmerged -eq 0 ]; then
    return 0
  else
    return 1
  fi
}

function git-not-has-changes {
  local git_ss="$(git status -s)"
  if [[ -z "$git_ss" ]]; then
    return 0
  else
    return 1
  fi
}

function git-has-changes {
  local git_ss="$(git status -s)"
  if [[ -z "$git_ss" ]]; then
    return 1
  else
    return 0
  fi
}

function git-find-first-tmp {
  git log --format="%h %s" -n 100 | while read line ; do
    if [[ -n "$(echo "$line" | grep -P '^\w+\s\d+$')" ]]; then
      local last="$line"
    else
      echo "$last" | sed -r -e 's/\s+[0-9]+//'
      break
    fi
  done
}

function git-find-last-tmp {
  local last="$(git log --format="%h %s" -n 1)"
  if [[ -n "$(echo "$last" | grep -P '^\w+\s\d+$')" ]]; then
    echo "$last" | sed -r -e 's/\s+[0-9]+//'
  fi
}

function __start__ {
  clr_black "$(clr_bg_white "                                             ")"
  echo
}

function __before__ {
  clr_black "$(clr_bg_cyan "      ðŸ¡¹  ðŸ¡¹  ðŸ¡¹      ðŸ¡¹  ðŸ¡¹  ðŸ¡¹      ðŸ¡¹  ðŸ¡¹  ðŸ¡¹      ")"
  echo
}

function __after__ {
  clr_black "$(clr_bg_magenta "      ðŸ¡»  ðŸ¡»  ðŸ¡»      ðŸ¡»  ðŸ¡»  ðŸ¡»      ðŸ¡»  ðŸ¡»  ðŸ¡»      ")"
  echo
}

function __git-unstaged-list__ {
  local git_ss="$(git status -s)"
  local notstaged="$(echo "$git_ss" | grep -s -P '^.M|^\?\?|^.D|^(.U|U.)' | cut -c4-)"
  echo "$notstaged" | sed -e 's/"//g'
}

function __git-staged-list__ {
  local git_ss="$(git status -s)"
  local staged="$(echo "$git_ss" | grep -s -P '^M|^R|^A|^D' | cut -c4-)"
  echo "$staged" | sed -e 's/"//g'
}

function __git-add__ {
  local paths="$1"
  if [[ -n "$paths" ]]; then
    echo "$paths" | while read line ; do
      echo "$(clr_black_i $) git add $(clr_yellow \""$line"\")"
      git add "$line"
      __print-on-error__
    done
    echo
  fi
}

function __git-unstage__ {
  local paths="$1"
  if [[ -n "$paths" ]]; then
    echo "$paths" | while read line ; do
      echo "$(clr_black_i $) git unstage $(clr_green \""$line"\")"
      git unstage "$line" > /dev/null
      __print-on-error__
    done
    echo
  fi
}

function __move-to-trash__ {
  local trash="$1"
  if [[ -n "trash" ]]; then
    echo "$trash" | while read line ; do
      echo "$(clr_black_i $) gvfs-trash -f \"$(clr_red_b "$line")\""
      gvfs-trash -f "$line"
      __print-on-error__
    done
    echo
  fi
}

function __git-rebase-squash-tmp__ {
  local commit="$1"

  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/script-squash-tmp.js") git rebase -i $(clr_cyan "$commit")^"
  echo

  __squash_rebase_output__="$(GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/script-squash-tmp.js" git rebase -i "$commit"^ 2>&1)"
  local last="$?"
  echo "$__squash_rebase_output__" | sed -e 's/\s/ /g'
  return $last
}

function __git-rebase-fixup__ {
  local cm_hash="$1"
  local cm_info="$2"
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR="$(which true)"") git rebase -i $(clr_cyan "$cm_hash")^"
  echo
  echo "$cm_info"

  __fixup_rebase_output__="$(GIT_SEQUENCE_EDITOR="$(which true)" git rebase -i "$cm_hash"^ 2>&1)"
  local last="$?"
  echo "$__fixup_rebase_output__" | sed -e 's/\s/ /g'
  return $last
}

function __git-verbose-box__ {
  local lw="$(expr "$(tput cols)" \* 4 / 9)"
  local rw="$(expr "$(tput cols)" \* 5 / 9)"

  local git_show_width="$(expr "$lw" - 2)"
  local git_show="$(git show --stat="$git_show_width" HEAD --color=always)"
  local git_log="$(git log-last)"

  __side_by-side__ "$lw" "magenta" "$git_show" "$rw" "cyan" "$git_log"
  __git-status-unexpected-box__
}

function __git-log-box__ {
  git log-last | boxen --border-color magenta
  __git-status-unexpected-box__
}

function __git-status-box__ {
  git -c color.status=always status | sed -e 's/\t/    /g' | boxen --border-color magenta
}

function __git-status-unexpected-box__ {
  if $(git-has-changes); then
    git -c color.status=always status | sed -e 's/\t/    /g' | boxen --border-color red
  fi
}

function __git-show__ {
  git show HEAD --stat --color=always
  echo
  __git-status-unexpected__
}

function __git-status-short__ {
  if $(git-has-changes); then
    git -c color.status=always status -s
    echo
  else
    clr_yellow "nothing to commit, working tree clean"
    echo
  fi
}

function __git-verbose__ {
  echo
  local num="$(git show HEAD --stat | tail -n1 | r1)"
  git show --stat HEAD --color=always | head -n -1 | tail -n "$num"
  echo
  git log-last
  echo
  __git-status-unexpected__
}

function __git-log__ {
  git log-last
  echo
  __git-status-unexpected__
}

function __git-status__ {
  git -c color.status=always status
  echo
}

function __git-status-unexpected__ {
  if $(git-has-changes); then
    clr_black "$(clr_bg_yellow "Changes:")"
    local asterisk="$(clr_black "$(clr_bg_yellow "*")")"
    git -c color.status=always status -s | while read line ; do
      echo "       $asterisk   $line"
    done
    echo
  fi
}

function __side_by-side__ {
  if [[ "$#" -eq "2" ]]; then
    local lw="$(expr "$(tput cols)" \* 4 / 9)"
    local rw="$(expr "$(tput cols)" \* 5 / 9)"
    "$HOME/.bash-tools/script-side-by-side" "$lw" "gray" "$1" "$rw" "yellow" "$2"
  elif [[ "$#" -eq "4" ]]; then
    local lw="$(expr "$(tput cols)" \* 4 / 9)"
    local rw="$(expr "$(tput cols)" \* 5 / 9)"
    "$HOME/.bash-tools/script-side-by-side" "$lw" "$1" "$2" "$rw" "$3" "$4"
  else
    "$HOME/.bash-tools/script-side-by-side" "$1" "$2" "$3" "$4" "$5" "$6"
  fi
}

function git-recommit-smart {
  if $(git-not-has-changes); then
      __start__

      echo "$(clr_black_i $) git recommit"
      echo
      git recommit
      __exit-on-error__
      echo

      __after__
      __git-show__
  else
    if [[ "$1" == '.' ]]; then
      local paths="$(__git-unstaged-list__)"
    elif $(git-not-has-staged); then
      local paths="$(gf)"
    fi

    if $(git-not-has-staged) && [[ -z "$paths" ]]; then
      clr_bg_blue "paths is not defined!"
      return 100
    fi

    __start__
    __git-add__ "$paths"
    __git-status-short__
    __before__

    echo "$(clr_black_i $) git recommit"
    echo
    git recommit
    __exit-on-error__
    echo

    __after__
    __git-show__
  fi
}

function git-rebase-smart {
  if [[ "$1" == "." ]]; then
    if [[ -z "$(git log --format="%s" -n 100 | grep -P "^fixup\!\s")" ]]; then
      git log-last
      clr_yellow "nothing to do!"
      return 2
    fi

    __git-smart-del-error__
    local before="$(__git-log__)"
    local output="$(
      while [[ -n "$(git log --format="%s" -n 100 | grep -P "^fixup\!\s")" ]]; do
        local fu_msg="$(git log --format="%s" -n1 --grep "^fixup\!\s")"
        local fu_hash="$(git log --format="%h" -n1 --grep "^fixup\!\s")"
        local cm_msg="$(echo "$fu_msg" | sed -r -e 's/^(fixup! )+//')"
        local cm_hash="$(git log --format="%h" -n1 "$fu_hash"^ --grep "^$cm_msg$")"
        if [[ -z "$fu_msg" ]] || [[ -z "$fu_hash" ]] || [[ -z "$cm_msg" ]] || [[ -z "$cm_hash" ]]; then
          clr_bg_red "can not found a base of last fixup!"
          echo -e "fu_msg: $fu_msg \nfu_hash: $fu_hash \ncm_msg: $cm_msg \ncm_hash: $cm_hash"
          __git-smart-set-error__ && break
        fi

        __git-rebase-fixup__ "$cm_hash" "($fu_hash) $fu_msg -> ($cm_hash) $cm_msg"
        __memoize-error__ && break
      done
    )"
    if [[ $(__git-smart-get-error__) -ne 0 ]]; then
      echo "$output"
      return $(__git-smart-get-error__)
    else
      __side_by-side__ "$before" "$output"
      __git-log-box__
    fi
  else
    local commit="$(gh)"
    if [[ -n "$commit" ]]; then
      __start__
      __git-log__
      __before__

      echo "$(clr_black_i $) git rebase -i $(clr_cyan "$commit")^"
      echo
      git rebase -i "$commit^"
      __exit-on-error__
      echo

      __after__
      __git-log__
    else
      clr_bg_blue "input was interrupted!"
      return 130
    fi
  fi
}

function git-commit-tmp {
  if $(git-not-has-changes); then
    __git-status__
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == '.' ]] || $(git-not-has-staged); then
    local paths="$(__git-unstaged-list__)"
  fi

  if $(git-not-has-staged) && [[ -z "$paths" ]]; then
    clr_bg_blue "has not staged and paths is not defined!"
    return 100
  fi

  __git-smart-del-error__
  local before="$(
    __git-add__ "$paths"
    __git-status__
  )"
  local output="$(
    local last=$(git log --format=%B -n 1 HEAD | rg '^[0-9]+$')
    local next="1"
    if [[ -n "$last" ]]; then
      next="$(expr $last + 1)"
    fi
    echo "$(clr_black_i $) git commit -m $(clr_cyan "$next")"
    echo
    git commit -m "$next" 2>&1
    __memoize-error__
  )"

  if [[ $(__git-smart-get-error__) -ne 0 ]]; then
    echo "$before"
    echo
    echo "$output"
    return $(__git-smart-get-error__)
  else
    __side_by-side__ "$before" "$output"
    __git-verbose-box__
  fi
}

function git-commit-smart {
  if $(git-not-has-changes); then
    __git-status__
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == '.' ]]; then
    local paths="$(__git-unstaged-list__)"
  elif $(git-not-has-staged); then
    local paths="$(gf)"
  fi

  if $(git-not-has-staged) && [[ -z "$paths" ]]; then
    clr_bg_blue "has not staged and paths is not defined!"
    return 100
  fi

  if ([[ "$1" == '.' ]] && [[ -z "$2" ]]) || [[ -z "$1" ]]; then
    __start__
    __git-add__ "$paths"
    __git-status-short__
    __before__
    echo "$(clr_black_i $) git commit"
    git commit
    __exit-on-error__
    echo
    __after__
    __git-verbose-box__
  else
    __git-smart-del-error__
    local before="$(
      __git-add__ "$paths"
      __git-status__
    )"
    local output="$(
      local summ
      for n in $@; do
        summ="$summ $n"
      done
      local trimmed="$(trim "$summ")"
      local undoted="$(echo "$trimmed" | sed -r -e 's/^\.\s+//')"
      echo "$(clr_black_i $) git commit -m \"$(clr_cyan "$undoted")\""
      echo
      git commit -m "$undoted" 2>&1
      __memoize-error__
    )"

    if [[ $(__git-smart-get-error__) -ne 0 ]]; then
      echo "$before"
      echo
      echo "$output"
      return $(__git-smart-get-error__)
    else
      __side_by-side__ "$before" "$output"
      __git-verbose-box__
    fi
  fi
}

function git-commit-fixup-smart {
  if $(git-not-has-changes); then
    __git-status__
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == '.' ]]; then
    local paths="$(__git-unstaged-list__)"
  elif $(git-not-has-staged); then
    local paths="$(gf)"
  fi

  if $(git-not-has-staged) && [[ -z "$paths" ]]; then
    clr_bg_blue "has not staged and paths is not defined!"
    return 100
  fi

  if [[ "$1" == "." ]]; then
    local commit="HEAD"
  elif [[ -n "$1" ]]; then
    local commit="$1"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    clr_bg_blue "commit is not defined!"
    return 100
  fi

  __git-smart-del-error__
  local before="$(
    __git-add__ "$paths"
    __git-status__
  )"
  local output="$(
    echo "$(clr_black_i $) git commit --fixup $(clr_cyan "$commit")"
    echo
    git commit --fixup $commit 2>&1
    __memoize-error__
  )"

  if [[ $(__git-smart-get-error__) -ne 0 ]]; then
    echo "$before"
    echo
    echo "$output"
    return $(__git-smart-get-error__)
  else
    __side_by-side__ "$before" "$output"
    __git-verbose-box__
  fi
}

function git-unstage-smart {
  if $(git-not-has-staged); then
    __git-status__
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == "." ]]; then
    local paths="$(__git-staged-list__)"
  elif [[ -n "$1" ]]; then
    for i ; do local paths="$(echo "$i"; echo "$paths")"; done
  else
    local paths="$(gf)"
  fi

  if [[ -z "$paths" ]]; then
    clr_bg_blue "paths is not defined!"
    return 100
  fi

  __git-smart-del-error__
  local before="$(__git-status__)"
  local output="$(
    __git-unstage__ "$paths"
    __memoize-error__
  )"

  if [[ $(__git-smart-get-error__) -ne 0 ]]; then
    echo "$output"
    return $(__git-smart-get-error__)
  else
    __side_by-side__ "$before" "$output"
    __git-status-box__
  fi
}

function git-add-smart {
  if $(git-not-has-unstaged); then
    __git-status__
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == "." ]]; then
    local paths="$(__git-unstaged-list__)"
  elif [[ -n "$1" ]]; then
    for i ; do local paths="$(echo "$i"; echo "$paths")"; done
  else
    local paths="$(gf)"
  fi

  if [[ -z "$paths" ]]; then
    clr_bg_blue "paths is not defined!"
    return 100
  fi

  __git-smart-del-error__
  local before="$(__git-status__)"
  local output="$(
    __git-add__ "$paths"
    __memoize-error__
  )"

  if [[ $(__git-smart-get-error__) -ne 0 ]]; then
    echo "$output"
    return $(__git-smart-get-error__)
  else
    __side_by-side__ "$before" "$output"
    __git-status-box__
  fi
}

function git-remove-untracked-smart {
  local git_ss="$(git status -s)"
  local added_notstaged=$(echo "$git_ss" | grep -c -s -P '^\?\?')

  if [[ "$added_notstaged" -eq 0 ]]; then
    __git-status__
    clr_yellow "nothing to do!"
    return 2
  fi

  local all="$(git status -s | grep "??" | sed -e "s/?? //")"
  if [[ "$1" == '.' ]]; then
    local trash="$all"
  else
    local trash="$(echo "$all" | fzf --multi \
      --bind 'ctrl-k:preview-up' \
      --bind 'ctrl-j:preview-down' \
      --preview '((echo $(basename {}) | grep .svg > /dev/null 2>&1 && rsvg {} tmp/preview.png && img2txt tmp/preview.png) \
                   || (file --mime {} | grep image > /dev/null 2>&1 && img2txt {}) \
                   || (file --mime {} | grep binary > /dev/null 2>&1 && echo {} is a binary file) \
                   || (highlight -O ansi -l {} || coderay {} || cat {})) 2> /dev/null | head -500')"
  fi

  if [[ -z "$trash" ]]; then
    clr_bg_blue "trash is not defined!"
    return 100
  fi

  __git-smart-del-error__
  local before="$(__git-status__)"
  local output="$(
    __move-to-trash__ "$trash"
    __memoize-error__
  )"

  if [[ $(__git-smart-get-error__) -ne 0 ]]; then
    echo "$output"
    return $(__git-smart-get-error__)
  else
    __side_by-side__ "$before" "$output"
    __git-status-box__
  fi
}

function git-squash-tmp-smart {
  if [[ "$1" == '.' ]]; then
    local commit="$(git-find-first-tmp)"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    __git-log__
    clr_yellow "nothing to do!"
    return 2
  fi

  local last="$(git-find-last-tmp)"
  if [[ "$commit" == "$last" ]]; then
    __git-log__
    clr_yellow "nothing to do!"
    return 2
  fi

  __git-smart-del-error__
  local before="$(__git-log__)"
  local output="$(
    __git-rebase-squash-tmp__ "$commit"
    __memoize-error__
  )"

  if [[ $(__git-smart-get-error__) -ne 0 ]]; then
    echo "$output"
    return $(__git-smart-get-error__)
  else
    __side_by-side__ "$before" "$output"
    __git-verbose-box__
  fi
}

function git-last-tmp-to-fixup-smart {
  if $(git-has-changes); then
    __git-status__
    clr_bg_red "cleanup project first!"
    return 3
  fi

  if [[ -z "$(git log --format="%h %s" -n1 | grep -P '^\w+\s\d+$')" ]]; then
    __git-log__
    clr_bg_red "last commit is not temporary!"
    return 4
  fi

  if [[ "$1" == "." ]]; then
    local commit="HEAD"
  elif [[ -n "$1" ]]; then
    local commit="$1"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    clr_bg_blue "commit is not defined!"
    return 100
  fi

  __git-smart-del-error__
  local before="$(__git-log__)"
  local output="$(
    echo "$(clr_black_i $) git uncommit"
    echo "$(clr_black_i $) git commit --fixup $(clr_cyan "$commit")"
    echo
    git uncommit 2>&1 && git commit --fixup $commit 2>&1
    __memoize-error__
  )"

  if [[ $(__git-smart-get-error__) -ne 0 ]]; then
    echo "$output"
    return $(__git-smart-get-error__)
  else
    __side_by-side__ "$before" "$output"
    __git-verbose-box__
  fi
}
