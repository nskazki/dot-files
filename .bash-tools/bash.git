#! /usr/bin/env bash

alias got='git'
alias gut='git'
alias get='git'
alias gti='git'

alias g='tig'
alias t='tig'
alias b='tig blame'
alias y='tig stash'

alias v='git view-commit-head'
alias vv='git view-commit'
alias l='echo && git log-last && echo'
alias s='git status-short'
alias ss='git status'
alias d='git diff'
alias ds='git diff-staged'

alias rb='git_rebase_smart'
alias rr='git_recombine_smart'
alias rc='git_recommit_smart'
alias rt='git_squash_tmp_smart'
alias rf='git_last_tmp_to_fixup_smart'
alias rh='git_hoist_smart'
alias rn='git_rename_smart'
alias c='git_commit_tmp'
alias f='git_commit_fixup_smart'
alias u='git_unstage_smart'
alias a='git_add_smart'
alias r='git_remove_untracked_smart'

alias git-drop-smart='git_drop_smart'
alias git-redate='git_redate'

alias rb.='rb .'
alias rc.='rc .'
alias rt.='rt .'
alias rf.='rf .'
alias rh.='rh .'
alias c.='c .'
alias f.='f .'
alias u.='u .'
alias a.='a .'
alias r.='r .'

alias rb,='rb .'
alias rc,='rc .'
alias rt,='rt .'
alias rf,='rf .'
alias rh,='rh .'
alias c,='c .'
alias f,='f .'
alias u,='u .'
alias a,='a .'
alias r,='r .'

alias __exit_on_error__='local last=$?; test $last -ne 0 && return $last'

function __git_has_uncommited__ {
  # https://stackoverflow.com/a/3879077
  git update-index -q --ignore-submodules --refresh
  ! git diff-index --cached --quiet HEAD --ignore-submodules
}

function __git_has_unstaged__ {
  git update-index -q --ignore-submodules --refresh
  ! git diff-files --quiet --ignore-submodules
}

function __git_has_changes__ {
  __git_has_uncommited__
  __git_has_unstaged__
}

function __git_find_first_tmp__ {
  git log --format="%h %s" -n 100 | while read line ; do
    if [[ "$line" =~ ^[[:alnum:]]+[[:space:]][[:digit:]]+$ ]]; then
      local last="$line"
    else
      echo "$last" | awk '{ print $1 }'
      break
    fi
  done
}

function __git_find_last_tmp__ {
  local last="$(git log --format="%h %s" -n 1)"
  if [[ "$last" =~ ^[[:alnum:]]+[[:space:]][[:digit:]]+$ ]]; then
    echo "$last" | awk '{ print $1 }'
  fi
}

function __git_unstaged_list__ {
  git diff-files --name-only -r --ignore-submodules
}

function __git_uncommited_list__ {
  git diff-index --cached --name-only -r --ignore-submodules HEAD
}

function __git_show__ {
  git view-commit-head
  echo
}

function __git_log__ {
  git log-last
  echo
}

function __git_status__ {
  git -c color.status=always status
  echo
}

function __git_fixup_targets__ {
  # https://stackoverflow.com/a/29613573
  git log --format="%s" -n 100 | grep -P "^fixup\!\s" | sed -r -e 's/^(fixup! )+//' | uniq | sed 's/[^^]/[&]/g; s/\^/\\^/g'
}

function git_recommit_smart {
  if [[ "$1" == '.' ]]; then
    local paths="$(__git_unstaged_list__)"
  fi

  echo
  echo "$paths" | while read line ; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add $(clr_yellow \""$line"\")"
      git add "$(git root)/$line"
      __exit_on_error__
    fi
  done

  echo "$(clr_black_i $) git recommit"
  echo
  git commit --amend --quiet
  __exit_on_error__
  __git_show__
}

function git_rebase_smart {
  if [[ "$1" == "." ]]; then
    if [[ -z "$(__git_fixup_targets__)" ]]; then
      clr_yellow "nothing to do!"
      return 2
    fi

    readarray -t lines <<< "$(__git_fixup_targets__)"
    local max="-1"
    for line in "${lines[@]}"; do
      local commit="$(git log --format="%h" -n1 --grep "^$line$")"
      local distance="$(git log --format="%h" $commit..HEAD | wc -l)"
      if [[ -z "$commit" || "$distance" = "0" ]]; then
        clr_bg_red "cannot find commit matching $line"
        return 1
      fi

      if (("$distance" > "$max")); then
        local max="$distance"
        local distanced_commit="$commit"
      fi
    done

    if [[ -z "$distanced_commit" ]]; then
      clr_bg_red "something went wrong"
      return 1
    fi

    echo
    echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR="$(which true)"") git rebase -i $(clr_cyan "$distanced_commit")^"
    echo
    GIT_SEQUENCE_EDITOR="$(which true)" git rebase -i "$distanced_commit^"
    __exit_on_error__
    echo
  else
    local commit="$(gh)"

    if [[ -z "$commit" ]]; then
      clr_bg_blue "input was interrupted!"
      return 130
    fi

    echo
    echo "$(clr_black_i $) git rebase -i $(clr_cyan "$commit")^"
    echo
    git rebase -i "$commit^"
    __exit_on_error__
    echo
  fi
}

function git_commit_tmp {
  if ! __git_has_changes__; then
    clr_yellow "nothing to do!"
    return 2
  fi

  local paths="$(__git_unstaged_list__)"

  echo
  echo "$paths" | while read line ; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add $(clr_yellow \""$line"\")"
      git add "$(git root)/$line"
      __exit_on_error__
    fi
  done

  local last="$(git log --format=%B -n 1 HEAD | head -n1 | rg '^[0-9]+$' -m1)"
  local next="1"
  if [[ -n "$last" ]]; then
    next="$(expr $last + 1)"
  fi

  echo "$(clr_black_i $) git commit -m $(clr_cyan "$next")"
  echo
  git commit -m "$next" --quiet
  __exit_on_error__
  __git_show__
}

function git_commit_fixup_smart {
  if ! __git_has_changes__; then
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == '.' ]]; then
    local paths="$(__git_unstaged_list__)"
  elif ! __git_has_uncommited__; then
    local paths="$(gf)"
  fi

  if ! __git_has_uncommited__ && [[ -z "$paths" ]]; then
    clr_bg_blue "has not staged and paths is not defined!"
    return 100
  fi

  if [[ "$1" == "." ]]; then
    local commit="HEAD"
  elif [[ -n "$1" ]]; then
    local commit="$1"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    clr_bg_blue "commit is not defined!"
    return 100
  fi

  echo
  echo "$paths" | while read line ; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add $(clr_yellow \""$line"\")"
      git add "$(git root)/$line"
      __exit_on_error__
    fi
  done

  echo "$(clr_black_i $) git commit --fixup $(clr_cyan "$commit")"
  echo
  git commit --quiet --fixup $commit
  __exit_on_error__
  __git_show__
}

function git_unstage_smart {
  if ! __git_has_uncommited__; then
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == "." ]]; then
    local paths="$(__git_uncommited_list__)"
  elif [[ -n "$1" ]]; then
    for i ; do local paths="$(echo "$i"; echo "$paths")"; done
  else
    local paths="$(gf)"
  fi

  if [[ -z "$paths" ]]; then
    clr_bg_blue "paths is not defined!"
    return 100
  fi

  echo
  echo "$paths" | while read line ; do
    echo "$(clr_black_i $) git unstage $(clr_green \""$line"\")"
    git unstage "$(git root)/$line" > /dev/null
    __exit_on_error__
  done

  echo
  __git_status__
}

function git_add_smart {
  if ! __git_has_unstaged__; then
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == "." ]]; then
    local paths="$(__git_unstaged_list__)"
  elif [[ -n "$1" ]]; then
    for i ; do local paths="$(echo "$i"; echo "$paths")"; done
  else
    local paths="$(gf)"
  fi

  if [[ -z "$paths" ]]; then
    clr_bg_blue "paths is not defined!"
    return 100
  fi

  echo
  echo "$paths" | while read line ; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add $(clr_yellow \""$line"\")"
      git add "$(git root)/$line"
      __exit_on_error__
    fi
  done

  echo
  __git_status__
}

function git_remove_untracked_smart {
  local git_ss="$(git status -s)"
  local added_notstaged=$(echo "$git_ss" | grep -c -s -P '^\?\?')

  if [[ "$added_notstaged" -eq 0 ]]; then
    clr_yellow "nothing to do!"
    return 2
  fi

  local all="$(git status -s | grep "??" | sed -e "s/?? //")"
  if [[ "$1" == '.' ]]; then
    local trash="$all"
  else
    local trash="$(echo "$all" | fzf --multi \
      --preview '((file --mime {} | grep directory > /dev/null 2>&1 && ls --color=always --group-directories-first -1 -lah {}) \
               || (file --mime {} | grep binary > /dev/null 2>&1 && echo {} is a binary file) \
               || (highlight -O ansi -l {} || coderay {} || cat {})) 2> /dev/null | head -500')"
  fi

  if [[ -z "$trash" ]]; then
    clr_bg_blue "trash is not defined!"
    return 100
  fi

  echo
  echo "$trash" | while read line ; do
    echo "$(clr_black_i $) gio trash -f \"$(clr_red_b "$line")\""
    gvfs-trash -f "$line"
    __exit_on_error__
  done

  echo
  __git_status__
}

function git_squash_tmp_smart {
  if [[ "$1" == '.' ]]; then
    local commit="$(__git_find_first_tmp__)"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    clr_yellow "nothing to do!"
    return 2
  fi

  local last="$(__git_find_last_tmp__)"
  if [[ "$commit" == "$last" ]]; then
    clr_yellow "nothing to do!"
    return 2
  fi

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-squash-tmp.js") git rebase -i $(clr_cyan "$commit")^"
  echo
  GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-squash-tmp.js" git rebase -i "$commit"^
  __exit_on_error__

  echo
  __git_show__
}

function git_last_tmp_to_fixup_smart {
  if __git_has_changes__; then
    __git_status__
    clr_bg_red "cleanup project first!"
    return 3
  fi

  if [[ -z "$(git log --format="%h %s" -n1 | grep -P '^\w+\s\d+$')" ]]; then
    __git_log__
    clr_bg_red "last commit is not temporary!"
    return 4
  fi

  if [[ "$1" == "." ]]; then
    local commit="HEAD"
  elif [[ -n "$1" ]]; then
    local commit="$1"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    clr_bg_blue "commit is not defined!"
    return 100
  fi

  echo
  echo "$(clr_black_i $) git uncommit"
  echo "$(clr_black_i $) git commit --fixup $(clr_cyan "$commit")"
  echo
  git uncommit && git commit --quiet --fixup "$commit"
  __exit_on_error__
  __git_show__
}

function git_hoist_smart {
  if [[ "$1" == "." && -z "$(git log --format="%h %s" -n 100 | grep -P '^\w+\s\d+$')" ]]; then
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == "." ]]; then
    local commits="$(git log --format="%h %s" -n 100 | grep -P '^\w+\s\d+$' | grep -P -o '^\w+')"
  else
    local commits="$(gh)"
  fi

  if [[ -z "$commits" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local last_commit="$(echo "$commits" | tail -n1)"

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-hoist.js") git rebase -i $(clr_cyan "$last_commit")^"
  echo
  COMMITS="$commits" GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-hoist.js" git rebase -i "$last_commit"^
  __exit_on_error__
  echo
}

function git_drop_smart {
  local commits="$(gh)"

  if [[ -z "$commits" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local last_commit="$(echo "$commits" | tail -n1)"

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-drop.js") git rebase -i $(clr_cyan "$last_commit")^"
  echo
  COMMITS="$commits" GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-drop.js" git rebase -i "$last_commit"^
  __exit_on_error__
  echo
}

function git_rename_smart {
  local commits="$(gh)"

  if [[ -z "$commits" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local last_commit="$(echo "$commits" | tail -n1)"

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-rename.js") git rebase -i $(clr_cyan "$last_commit")^"
  echo
  COMMITS="$commits" GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-rename.js" git rebase -i "$last_commit"^
  __exit_on_error__
  echo
}

function git_recombine_smart {
  local commits="$(gh)"

  if [[ -z "$commits" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local last_commit="$(echo "$commits" | tail -n1)"

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-recombine.js") git rebase -i $(clr_cyan "$last_commit")^"
  echo
  COMMITS="$commits" GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-recombine.js" git rebase -i "$last_commit"^
  __exit_on_error__
  echo
}

function git_redate {
  local commit="$(gh)"

  if [[ -z "$commit" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local format="$(echo -e "author date\ncommit date" | fzf --preview "\
                  ([[ {1} == 'author' ]] \
                    && git log --format="%ad" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD \
                    || git log --format="%cd" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD) | sort -r")"

  if [[ -z "$format" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local commits="$(git log --format="%H" $commit^..HEAD)"
  local dates="$([[ "$format" == "author date" ]] \
                  && git log --format="%ad" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD | sort -r \
                  || git log --format="%cd" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD | sort -r)"

  local filter="$(node -e '
    const dateList = process.argv[1].split("\n")
    const commitList = process.argv[2].split("\n")

    let filter = ""
    for (let index = 0; index !== commitList.length; index++) {
      const date = dateList[index]
      const commit = commitList[index]
      filter += `
        ${index === 0 ? "if" : "elif"} [ $GIT_COMMIT = ${commit} ]; then
          GIT_AUTHOR_DATE="${date}"
          GIT_COMMITTER_DATE="${date}"
          git commit-tree "$@"`
    }
    filter += `
        else
          git commit-tree "$@"
        fi`
    console.info(filter)
  ' "$dates" "$commits")"

  echo "$filter"

  git filter-branch -f --commit-filter "$filter" $commit^..HEAD
}
