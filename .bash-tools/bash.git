#! /usr/bin/env bash

alias got='git'
alias gut='git'
alias get='git'
alias gti='git'

alias g='tig'
alias t='tig'
alias b='tig blame'
alias y='tig stash'

alias v='git view-commit-head'
alias vv='git view-commit'
alias l='echo && git log-last && echo'
alias s='git status-short'
alias ss='git status'
alias d='git diff'
alias ds='git diff-staged'

alias rb='git_rebase_smart'
alias rr='git_recombine_smart'
alias rc='git_recommit_smart'
alias rt='git_squash_tmp_smart'
alias rf='git_last_tmp_to_fixup_smart'
alias rh='git_hoist_smart'
alias rn='git_rename_smart'
alias c='git_commit_tmp'
alias f='git_commit_fixup_smart'
alias u='git_unstage_smart'
alias a='git_add_smart'
alias r='git_remove_untracked_smart'

alias git-drop-smart='git_drop_smart'
alias git-redate='git_redate'

alias rb.='rb .'
alias rc.='rc .'
alias rt.='rt .'
alias rf.='rf .'
alias rh.='rh .'
alias c.='c .'
alias f.='f .'
alias u.='u .'
alias a.='a .'
alias r.='r .'

alias rb,='rb .'
alias rc,='rc .'
alias rt,='rt .'
alias rf,='rf .'
alias rh,='rh .'
alias c,='c .'
alias f,='f .'
alias u,='u .'
alias a,='a .'
alias r,='r .'

alias __exit_on_error__='local last=$?; test $last -ne 0 && return $last'

function __git_has_not_staged__ {
  local git_ss="$(git status -s)"
  local modified_staged="$(echo "$git_ss" | grep -c -s -P '^M')"
  local renamed="$(echo "$git_ss" | grep -c -s -P '^R')"
  local added_staged="$(echo "$git_ss" | grep -c -s -P '^A')"
  local deleted_staged="$(echo "$git_ss" | grep -c -s -P '^D')"
  if [[ "$modified_staged" -eq 0 && "$renamed" -eq 0 && "$added_staged" -eq 0 && "$deleted_staged" -eq 0 ]]; then
    return 0
  else
    return 1
  fi
}

function __git_has_not_unstaged__ {
  local git_ss="$(git status -s)"
  local modified_notstaged="$(echo "$git_ss" | grep -c -s -P '^.M')"
  local added_notstaged="$(echo "$git_ss" | grep -c -s -P '^\?\?')"
  local deleted_notstaged="$(echo "$git_ss" | grep -c -s -P '^.D')"
  local unmerged="$(echo "$git_ss" | grep -c -s -P '^(.U|U.)')"
  if [[ "$modified_notstaged" -eq 0 && "$added_notstaged" -eq 0 && "$deleted_notstaged" -eq 0 && "$unmerged" -eq 0 ]]; then
    return 0
  else
    return 1
  fi
}

function __git_has_not_changes__ {
  local git_ss="$(git status -s)"
  if [[ -z "$git_ss" ]]; then
    return 0
  else
    return 1
  fi
}

function __git_has_changes__ {
  local git_ss="$(git status -s)"
  if [[ -z "$git_ss" ]]; then
    return 1
  else
    return 0
  fi
}

function __git_find_first_tmp__ {
  git log --format="%h %s" -n 100 | while read line ; do
    if [[ "$line" =~ ^[[:alnum:]]+[[:space:]][[:digit:]]+$ ]]; then
      local last="$line"
    else
      echo "$last" | sed -r -e 's/\s+[0-9]+//'
      break
    fi
  done
}

function __git_find_last_tmp__ {
  local last="$(git log --format="%h %s" -n 1)"
  if [[ "$last" =~ ^[[:alnum:]]+[[:space:]][[:digit:]]+$ ]]; then
    echo "$last" | sed -r -e 's/\s+[0-9]+//'
  fi
}

function __git_unstaged_list__ {
  local git_ss="$(git status -s)"
  local notstaged="$(echo "$git_ss" | grep -s -P '^.M|^\?\?|^.D|^(.U|U.)' | cut -c4-)"
  echo "$notstaged" | sed -e 's/"//g'
}

function __git_staged_list__ {
  local git_ss="$(git status -s)"
  local staged="$(echo "$git_ss" | grep -s -P '^M|^R|^A|^D' | cut -c4-)"
  echo "$staged" | sed -e 's/"//g'
}

function __git_show__ {
  git show --pretty=fuller HEAD --stat --color=always
  echo
}

function __git_log__ {
  git log-last
  echo
}

function __git_status__ {
  git -c color.status=always status
  echo
}

function git_recommit_smart {
  if [[ "$1" == '.' ]]; then
    local paths="$(git_unstaged_list)"
  fi

  echo
  echo "$paths" | while read line ; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add $(clr_yellow \""$line"\")"
      git add "$line"
      __exit_on_error__
    fi
  done

  echo "$(clr_black_i $) git recommit"
  echo
  git commit --amend --quiet
  __exit_on_error__
  __git_show__
}

function git_rebase_smart {
  if [[ "$1" == "." ]]; then
    if [[ -z "$(git log --format="%s" -n 100 | grep -P "^fixup\!\s")" ]]; then
      clr_yellow "nothing to do!"
      return 2
    fi

    while [[ -n "$(git log --format="%s" -n 100 | grep -P "^fixup\!\s")" ]]; do
      local fu_msg="$(git log --format="%s" -n1 --grep "^fixup\!\s")"
      local fu_hash="$(git log --format="%h" -n1 --grep "^fixup\!\s")"
      local cm_msg="$(echo "$fu_msg" | sed -r -e 's/^(fixup! )+//' | sed -r -e 's/\\/\\\\/g')"
      local cm_hash="$(git log --format="%h" -n1 "$fu_hash"^ --grep "^$cm_msg$")"

      if [[ -z "$fu_msg" || -z "$fu_hash" || -z "$cm_msg" || -z "$cm_hash" ]]; then
        clr_bg_red "could not find a base of last fixup!"
        echo -e "fu_msg: $fu_msg \nfu_hash: $fu_hash \ncm_msg: $cm_msg \ncm_hash: $cm_hash"
        return 1
      fi

      echo
      echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR="$(which true)"") git rebase -i $(clr_cyan "$cm_hash")^"
      echo
      echo "($fu_hash) $fu_msg -> ($cm_hash) $cm_msg"
      GIT_SEQUENCE_EDITOR="$(which true)" git rebase -i "$cm_hash"^
      __exit_on_error__
    done
    echo
  else
    local commit="$(gh)"

    if [[ -z "$commit" ]]; then
      clr_bg_blue "input was interrupted!"
      return 130
    fi

    echo
    echo "$(clr_black_i $) git rebase -i $(clr_cyan "$commit")^"
    echo
    git rebase -i "$commit^"
    __exit_on_error__
    echo
  fi
}

function git_commit_tmp {
  if __git_has_not_changes__; then
    clr_yellow "nothing to do!"
    return 2
  fi

  local paths="$(git_unstaged_list)"

  echo
  echo "$paths" | while read line ; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add $(clr_yellow \""$line"\")"
      git add "$line"
      __exit_on_error__
    fi
  done

  local last="$(git log --format=%B -n 1 HEAD | head -n1 | rg '^[0-9]+$' -m1)"
  local next="1"
  if [[ -n "$last" ]]; then
    next="$(expr $last + 1)"
  fi

  echo "$(clr_black_i $) git commit -m $(clr_cyan "$next")"
  echo
  git commit -m "$next" --quiet
  __exit_on_error__
  __git_show__
}

function git_commit_fixup_smart {
  if __git_has_not_changes__; then
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == '.' ]]; then
    local paths="$(git_unstaged_list)"
  elif __git_has_not_staged__; then
    local paths="$(gf)"
  fi

  if __git_has_not_staged__ && [[ -z "$paths" ]]; then
    clr_bg_blue "has not staged and paths is not defined!"
    return 100
  fi

  if [[ "$1" == "." ]]; then
    local commit="HEAD"
  elif [[ -n "$1" ]]; then
    local commit="$1"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    clr_bg_blue "commit is not defined!"
    return 100
  fi

  echo
  echo "$paths" | while read line ; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add $(clr_yellow \""$line"\")"
      git add "$line"
      __exit_on_error__
    fi
  done

  echo "$(clr_black_i $) git commit --fixup $(clr_cyan "$commit")"
  echo
  git commit --quiet --fixup $commit
  __exit_on_error__
  __git_show__
}

function git_unstage_smart {
  if __git_has_not_staged__; then
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == "." ]]; then
    local paths="$(__git_staged_list__)"
  elif [[ -n "$1" ]]; then
    for i ; do local paths="$(echo "$i"; echo "$paths")"; done
  else
    local paths="$(gf)"
  fi

  if [[ -z "$paths" ]]; then
    clr_bg_blue "paths is not defined!"
    return 100
  fi

  echo
  echo "$paths" | while read line ; do
    echo "$(clr_black_i $) git unstage $(clr_green \""$line"\")"
    git unstage "$line" > /dev/null
    __exit_on_error__
  done

  echo
  __git_status__
}

function git_add_smart {
  if __git_has_not_unstaged__; then
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == "." ]]; then
    local paths="$(git_unstaged_list)"
  elif [[ -n "$1" ]]; then
    for i ; do local paths="$(echo "$i"; echo "$paths")"; done
  else
    local paths="$(gf)"
  fi

  if [[ -z "$paths" ]]; then
    clr_bg_blue "paths is not defined!"
    return 100
  fi

  echo
  echo "$paths" | while read line ; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add $(clr_yellow \""$line"\")"
      git add "$line"
      __exit_on_error__
    fi
  done

  echo
  __git_status__
}

function git_remove_untracked_smart {
  local git_ss="$(git status -s)"
  local added_notstaged=$(echo "$git_ss" | grep -c -s -P '^\?\?')

  if [[ "$added_notstaged" -eq 0 ]]; then
    clr_yellow "nothing to do!"
    return 2
  fi

  local all="$(git status -s | grep "??" | sed -e "s/?? //")"
  if [[ "$1" == '.' ]]; then
    local trash="$all"
  else
    local trash="$(echo "$all" | fzf --multi \
      --preview '((file --mime {} | grep directory > /dev/null 2>&1 && ls --color=always --group-directories-first -1 -lah {}) \
               || (file --mime {} | grep binary > /dev/null 2>&1 && echo {} is a binary file) \
               || (highlight -O ansi -l {} || coderay {} || cat {})) 2> /dev/null | head -500')"
  fi

  if [[ -z "$trash" ]]; then
    clr_bg_blue "trash is not defined!"
    return 100
  fi

  echo
  echo "$trash" | while read line ; do
    echo "$(clr_black_i $) gvfs-trash -f \"$(clr_red_b "$line")\""
    gvfs-trash -f "$line"
    __exit_on_error__
  done

  echo
  __git_status__
}

function git_squash_tmp_smart {
  if [[ "$1" == '.' ]]; then
    local commit="$(__git_find_first_tmp__)"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    clr_yellow "nothing to do!"
    return 2
  fi

  local last="$(__git_find_last_tmp__)"
  if [[ "$commit" == "$last" ]]; then
    clr_yellow "nothing to do!"
    return 2
  fi

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-squash-tmp.js") git rebase -i $(clr_cyan "$commit")^"
  echo
  GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-squash-tmp.js" git rebase -i "$commit"^
  __exit_on_error__

  echo
  __git_show__
}

function git_last_tmp_to_fixup_smart {
  if __git_has_changes__; then
    __git_status__
    clr_bg_red "cleanup project first!"
    return 3
  fi

  if [[ -z "$(git log --format="%h %s" -n1 | grep -P '^\w+\s\d+$')" ]]; then
    __git_log__
    clr_bg_red "last commit is not temporary!"
    return 4
  fi

  if [[ "$1" == "." ]]; then
    local commit="HEAD"
  elif [[ -n "$1" ]]; then
    local commit="$1"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    clr_bg_blue "commit is not defined!"
    return 100
  fi

  echo
  echo "$(clr_black_i $) git uncommit"
  echo "$(clr_black_i $) git commit --fixup $(clr_cyan "$commit")"
  echo
  git uncommit && git commit --quiet --fixup "$commit"
  __exit_on_error__
  __git_show__
}

function git_hoist_smart {
  if [[ "$1" == "." && -z "$(git log --format="%h %s" -n 100 | grep -P '^\w+\s\d+$')" ]]; then
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == "." ]]; then
    local commits="$(git log --format="%h %s" -n 100 | grep -P '^\w+\s\d+$' | grep -P -o '^\w+')"
  else
    local commits="$(gh)"
  fi

  if [[ -z "$commits" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local last_commit="$(echo "$commits" | tail -n1)"

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-hoist.js") git rebase -i $(clr_cyan "$last_commit")^"
  echo
  COMMITS="$commits" GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-hoist.js" git rebase -i "$last_commit"^
  __exit_on_error__
  echo
}

function git_drop_smart {
  local commits="$(gh)"

  if [[ -z "$commits" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local last_commit="$(echo "$commits" | tail -n1)"

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-drop.js") git rebase -i $(clr_cyan "$last_commit")^"
  echo
  COMMITS="$commits" GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-drop.js" git rebase -i "$last_commit"^
  __exit_on_error__
  echo
}

function git_rename_smart {
  local commits="$(gh)"

  if [[ -z "$commits" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local last_commit="$(echo "$commits" | tail -n1)"

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-rename.js") git rebase -i $(clr_cyan "$last_commit")^"
  echo
  COMMITS="$commits" GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-rename.js" git rebase -i "$last_commit"^
  __exit_on_error__
  echo
}

function git_recombine_smart {
  local commits="$(gh)"

  if [[ -z "$commits" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local last_commit="$(echo "$commits" | tail -n1)"

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-recombine.js") git rebase -i $(clr_cyan "$last_commit")^"
  echo
  COMMITS="$commits" GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-recombine.js" git rebase -i "$last_commit"^
  __exit_on_error__
  echo
}

function git_redate {
  local commit="$(gh)"

  if [[ -z "$commit" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local format="$(echo -e "author date\ncommit date" | fzf --preview "\
                  ([[ {1} == 'author' ]] \
                    && git log --format="%ad" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD \
                    || git log --format="%cd" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD) | sort -r")"

  if [[ -z "$format" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local commits="$(git log --format="%H" $commit^..HEAD)"
  local dates="$([[ "$format" == "author date" ]] \
                  && git log --format="%ad" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD | sort -r \
                  || git log --format="%cd" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD | sort -r)"

  local filter="$(node -e '
    const dateList = process.argv[1].split("\n")
    const commitList = process.argv[2].split("\n")

    let filter = ""
    for (let index = 0; index !== commitList.length; index++) {
      const date = dateList[index]
      const commit = commitList[index]
      filter += `
        ${index === 0 ? "if" : "elif"} [ $GIT_COMMIT = ${commit} ]; then
          GIT_AUTHOR_DATE="${date}"
          GIT_COMMITTER_DATE="${date}"
          git commit-tree "$@"`
    }
    filter += `
        else
          git commit-tree "$@"
        fi`
    console.info(filter)
  ' "$dates" "$commits")"

  echo "$filter"

  git filter-branch -f --commit-filter "$filter" $commit^..HEAD
}
