#! /usr/bin/env bash

# !git-tools
alias got='git'
alias gut='git'
alias get='git'
alias gti='git'

function g {
  if [[ -z $1 ]]; then
    tig
  elif [[ -f "$(resolve "$1")" ]] || [[ -d "$(resolve "$1")" ]]; then
    tig $@
  elif [[ -n "$(echo "$1" | grep -P '[\w-/]+\.{2,3}[\w-/]+')" ]]; then
    tig $@
  else
    git $@
  fi
}

alias t='tig'
alias b='tig blame'
alias y='tig stash'

alias v='git view-commit'
alias l='git log-last'
alias s='git status-short'
alias ss='git status'
alias d='git diff'
alias ds='git diff-staged'

alias rb='git-rebase-smart'
alias rc='git-recommit-smart'
alias rt='git-squash-tmp-smart'
alias rf='git-last-tmp-to-fixup-smart'
alias rh='git-hoist-smart'
alias c='git-commit-tmp'
alias f='git-commit-fixup-smart'
alias u='git-unstage-smart'
alias a='git-add-smart'
alias r='git-remove-untracked-smart'

alias rb.='rb .'
alias rc.='rc .'
alias rt.='rt .'
alias rf.='rf .'
alias rh.='rh .'
alias c.='c .'
alias f.='f .'
alias u.='u .'
alias a.='a .'
alias r.='r .'

alias rb,='rb .'
alias rc,='rc .'
alias rt,='rt .'
alias rf,='rf .'
alias rh,='rh .'
alias c,='c .'
alias f,='f .'
alias u,='u .'
alias a,='a .'
alias r,='r .'

alias __exit-on-error__='local last=$?; test $last -ne 0 && return $last'

function git-not-has-staged {
  local git_ss="$(git status -s)"
  local modified_staged=$(echo "$git_ss" | grep -c -s -P '^M')
  local renamed=$(echo "$git_ss" | grep -c -s -P '^R')
  local added_staged=$(echo "$git_ss" | grep -c -s -P '^A')
  local deleted_staged=$(echo "$git_ss" | grep -c -s -P '^D')
  if [ $modified_staged -eq 0 ] && [ $renamed -eq 0 ] && [ $added_staged -eq 0 ] && [ $deleted_staged -eq 0 ]; then
    return 0
  else
    return 1
  fi
}

function git-not-has-unstaged {
  local git_ss="$(git status -s)"
  local modified_notstaged=$(echo "$git_ss" | grep -c -s -P '^.M')
  local added_notstaged=$(echo "$git_ss" | grep -c -s -P '^\?\?')
  local deleted_notstaged=$(echo "$git_ss" | grep -c -s -P '^.D')
  local unmerged=$(echo "$git_ss" | grep -c -s -P '^(.U|U.)')
  if [ $modified_notstaged -eq 0 ] && [ $added_notstaged -eq 0 ] && [ $deleted_notstaged -eq 0 ] && [ $unmerged -eq 0 ]; then
    return 0
  else
    return 1
  fi
}

function git-not-has-changes {
  local git_ss="$(git status -s)"
  if [[ -z "$git_ss" ]]; then
    return 0
  else
    return 1
  fi
}

function git-has-changes {
  local git_ss="$(git status -s)"
  if [[ -z "$git_ss" ]]; then
    return 1
  else
    return 0
  fi
}

function git-find-first-tmp {
  git log --format="%h %s" -n 100 | while read line ; do
    if [[ -n "$(echo "$line" | grep -P '^\w+\s\d+$')" ]]; then
      local last="$line"
    else
      echo "$last" | sed -r -e 's/\s+[0-9]+//'
      break
    fi
  done
}

function git-find-last-tmp {
  local last="$(git log --format="%h %s" -n 1)"
  if [[ -n "$(echo "$last" | grep -P '^\w+\s\d+$')" ]]; then
    echo "$last" | sed -r -e 's/\s+[0-9]+//'
  fi
}

function __git-unstaged-list__ {
  local git_ss="$(git status -s)"
  local notstaged="$(echo "$git_ss" | grep -s -P '^.M|^\?\?|^.D|^(.U|U.)' | cut -c4-)"
  echo "$notstaged" | sed -e 's/"//g'
}

function __git-staged-list__ {
  local git_ss="$(git status -s)"
  local staged="$(echo "$git_ss" | grep -s -P '^M|^R|^A|^D' | cut -c4-)"
  echo "$staged" | sed -e 's/"//g'
}

function __git-show__ {
  git show --pretty=fuller HEAD --stat --color=always
  __git-status-unexpected__
  echo
}

function __git-log__ {
  git log-last
  __git-status-unexpected__
  echo
}

function __git-status__ {
  git -c color.status=always status
  echo
}

function __git-status-short__ {
  if $(git-has-changes); then
    git -c color.status=always status -s
    echo
  else
    clr_yellow "nothing to commit, working tree clean"
    echo
  fi
}

function __git-status-unexpected__ {
  if $(git-has-changes); then
    echo
    clr_black "$(clr_bg_yellow "Changes:")"
    local asterisk="$(clr_black "$(clr_bg_yellow "*")")"
    git -c color.status=always status -s | while read line ; do
      echo "       $asterisk   $line"
    done
  fi
}

function git-recommit-smart {
  if [[ "$1" == '.' ]]; then
    local paths="$(__git-unstaged-list__)"
  fi

  echo
  echo "$paths" | while read line ; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add $(clr_yellow \""$line"\")"
      git add "$line"
      __exit-on-error__
    fi
  done

  echo "$(clr_black_i $) git recommit"
  echo
  git commit --amend --quiet
  __exit-on-error__

  __git-show__
}

function git-rebase-smart {
  if [[ "$1" == "." ]]; then
    if [[ -z "$(git log --format="%s" -n 100 | grep -P "^fixup\!\s")" ]]; then
      __git-log__
      clr_yellow "nothing to do!"
      return 2
    fi

    while [[ -n "$(git log --format="%s" -n 100 | grep -P "^fixup\!\s")" ]]; do
      local fu_msg="$(git log --format="%s" -n1 --grep "^fixup\!\s")"
      local fu_hash="$(git log --format="%h" -n1 --grep "^fixup\!\s")"
      local cm_msg="$(echo "$fu_msg" | sed -r -e 's/^(fixup! )+//' | sed -r -e 's/\\/\\\\/g')"
      local cm_hash="$(git log --format="%h" -n1 "$fu_hash"^ --grep "^$cm_msg$")"

      if [[ -z "$fu_msg" ]] || [[ -z "$fu_hash" ]] || [[ -z "$cm_msg" ]] || [[ -z "$cm_hash" ]]; then
        clr_bg_red "can not found a base of last fixup!"
        echo -e "fu_msg: $fu_msg \nfu_hash: $fu_hash \ncm_msg: $cm_msg \ncm_hash: $cm_hash"
        return 1
      fi

      echo
      echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR="$(which true)"") git rebase -i $(clr_cyan "$cm_hash")^"
      echo
      echo "($fu_hash) $fu_msg -> ($cm_hash) $cm_msg"
      GIT_SEQUENCE_EDITOR="$(which true)" git rebase -i "$cm_hash"^
      __exit-on-error__
    done

    echo
    __git-log__
  else
    local commit="$(gh)"

    if [[ -z "$commit" ]]; then
      clr_bg_blue "input was interrupted!"
      return 130
    fi

    echo
    echo "$(clr_black_i $) git rebase -i $(clr_cyan "$commit")^"
    echo
    git rebase -i "$commit^"
    __exit-on-error__

    echo
    __git-log__
  fi
}

function git-commit-tmp {
  if $(git-not-has-changes); then
    __git-status__
    clr_yellow "nothing to do!"
    return 2
  fi

  local paths="$(__git-unstaged-list__)"

  echo
  echo "$paths" | while read line ; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add $(clr_yellow \""$line"\")"
      git add "$line"
      __exit-on-error__
    fi
  done

  local last=$(git log --format=%B -n 1 HEAD | rg '^[0-9]+$')
  local next="1"
  if [[ -n "$last" ]]; then
    next="$(expr $last + 1)"
  fi

  echo "$(clr_black_i $) git commit -m $(clr_cyan "$next")"
  echo
  git commit -m "$next" --quiet
  __exit-on-error__

  __git-show__
  __git-log__
}

function git-commit-fixup-smart {
  if $(git-not-has-changes); then
    __git-status__
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == '.' ]]; then
    local paths="$(__git-unstaged-list__)"
  elif $(git-not-has-staged); then
    local paths="$(gf)"
  fi

  if $(git-not-has-staged) && [[ -z "$paths" ]]; then
    clr_bg_blue "has not staged and paths is not defined!"
    return 100
  fi

  if [[ "$1" == "." ]]; then
    local commit="HEAD"
  elif [[ -n "$1" ]]; then
    local commit="$1"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    clr_bg_blue "commit is not defined!"
    return 100
  fi

  echo
  echo "$paths" | while read line ; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add $(clr_yellow \""$line"\")"
      git add "$line"
      __exit-on-error__
    fi
  done

  echo "$(clr_black_i $) git commit --fixup $(clr_cyan "$commit")"
  echo
  git commit --quiet --fixup $commit
  __exit-on-error__

  __git-show__
  __git-log__
}

function git-unstage-smart {
  if $(git-not-has-staged); then
    __git-status__
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == "." ]]; then
    local paths="$(__git-staged-list__)"
  elif [[ -n "$1" ]]; then
    for i ; do local paths="$(echo "$i"; echo "$paths")"; done
  else
    local paths="$(gf)"
  fi

  if [[ -z "$paths" ]]; then
    clr_bg_blue "paths is not defined!"
    return 100
  fi

  echo
  echo "$paths" | while read line ; do
    echo "$(clr_black_i $) git unstage $(clr_green \""$line"\")"
    git unstage "$line" > /dev/null
    __exit-on-error__
  done

  echo
  __git-status-short__
}

function git-add-smart {
  if $(git-not-has-unstaged); then
    __git-status__
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == "." ]]; then
    local paths="$(__git-unstaged-list__)"
  elif [[ -n "$1" ]]; then
    for i ; do local paths="$(echo "$i"; echo "$paths")"; done
  else
    local paths="$(gf)"
  fi

  if [[ -z "$paths" ]]; then
    clr_bg_blue "paths is not defined!"
    return 100
  fi

  echo
  echo "$paths" | while read line ; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add $(clr_yellow \""$line"\")"
      git add "$line"
      __exit-on-error__
    fi
  done

  echo
  __git-status-short__
}

function git-remove-untracked-smart {
  local git_ss="$(git status -s)"
  local added_notstaged=$(echo "$git_ss" | grep -c -s -P '^\?\?')

  if [[ "$added_notstaged" -eq 0 ]]; then
    __git-status__
    clr_yellow "nothing to do!"
    return 2
  fi

  local all="$(git status -s | grep "??" | sed -e "s/?? //")"
  if [[ "$1" == '.' ]]; then
    local trash="$all"
  else
    local trash="$(echo "$all" | fzf --multi \
      --preview '((echo $(basename {}) | grep .svg > /dev/null 2>&1 && rsvg {} tmp/preview.png && img2txt tmp/preview.png) \
                   || (file --mime {} | grep image > /dev/null 2>&1 && img2txt {}) \
                   || (file --mime {} | grep binary > /dev/null 2>&1 && echo {} is a binary file) \
                   || (highlight -O ansi -l {} || coderay {} || cat {})) 2> /dev/null | head -500')"
  fi

  if [[ -z "$trash" ]]; then
    clr_bg_blue "trash is not defined!"
    return 100
  fi

  echo
  echo "$trash" | while read line ; do
    echo "$(clr_black_i $) gvfs-trash -f \"$(clr_red_b "$line")\""
    gvfs-trash -f "$line"
    __exit-on-error__
  done

  echo
  __git-status-short__
}

function git-squash-tmp-smart {
  if [[ "$1" == '.' ]]; then
    local commit="$(git-find-first-tmp)"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    __git-log__
    clr_yellow "nothing to do!"
    return 2
  fi

  local last="$(git-find-last-tmp)"
  if [[ "$commit" == "$last" ]]; then
    __git-log__
    clr_yellow "nothing to do!"
    return 2
  fi

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/script-squash-tmp.js") git rebase -i $(clr_cyan "$commit")^"
  echo
  GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/script-squash-tmp.js" git rebase -i "$commit"^
  __exit-on-error__

  echo
  __git-log__
}

function git-last-tmp-to-fixup-smart {
  if $(git-has-changes); then
    __git-status__
    clr_bg_red "cleanup project first!"
    return 3
  fi

  if [[ -z "$(git log --format="%h %s" -n1 | grep -P '^\w+\s\d+$')" ]]; then
    __git-log__
    clr_bg_red "last commit is not temporary!"
    return 4
  fi

  if [[ "$1" == "." ]]; then
    local commit="HEAD"
  elif [[ -n "$1" ]]; then
    local commit="$1"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    clr_bg_blue "commit is not defined!"
    return 100
  fi

  echo
  echo "$(clr_black_i $) git uncommit"
  echo "$(clr_black_i $) git commit --fixup $(clr_cyan "$commit")"
  echo
  git uncommit && git commit --quiet --fixup "$commit"
  __exit-on-error__

  __git-log__
}

function git-hoist-smart {
  if [[ "$1" == "." ]] && [[ -z "$(git log --format="%h %s" -n 100 | grep -P '^\w+\s\d+$')" ]]; then
    __git-log__
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == "." ]]; then
    local commits="$(git log --format="%h %s" -n 100 | grep -P '^\w+\s\d+$' | grep -P -o '^\w+')"
  else
    local commits="$(gh)"
  fi

  if [[ -z "$commits" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local last_commit="$(echo "$commits" | tail -n1)"

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/script-hoist.js") git rebase -i $(clr_cyan "$last_commit")^"
  echo
  COMMITS="$commits" GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/script-hoist.js" git rebase -i "$last_commit"^
  __exit-on-error__

  echo
  __git-log__
}

function git-drop-smart {
  local commits="$(gh)"

  if [[ -z "$commits" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local last_commit="$(echo "$commits" | tail -n1)"

  echo
  __git-log__

  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/script-drop.js") git rebase -i $(clr_cyan "$last_commit")^"
  echo
  COMMITS="$commits" GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/script-drop.js" git rebase -i "$last_commit"^
  __exit-on-error__

  echo
  __git-log__
}

function git-redate {
  local commit="$(gh)"

  if [[ -z "$commit" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local format="$(echo -e "author date\ncommit date" | fzf --preview "\
                  ([[ {1} == 'author' ]] \
                    && git log --format="%ad" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD \
                    || git log --format="%cd" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD) | sort -r")"

  if [[ -z "$format" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local commits="$(git log --format="%H" $commit^..HEAD)"
  local dates="$([[ "$format" == "author date" ]] \
                  && git log --format="%ad" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD | sort -r \
                  || git log --format="%cd" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD | sort -r)"

  local filter="$(node -e '
    const dateList = process.argv[1].split("\n")
    const commitList = process.argv[2].split("\n")

    let filter = ""
    for (let index = 0; index !== commitList.length; index++) {
      const date = dateList[index]
      const commit = commitList[index]
      filter += `
        ${index === 0 ? "if" : "elif"} [ $GIT_COMMIT = ${commit} ]; then
          GIT_AUTHOR_DATE="${date}"
          GIT_COMMITTER_DATE="${date}"
          git commit-tree "$@"`
    }
    filter += `
        else
          git commit-tree "$@"
        fi`
    console.info(filter)
  ' "$dates" "$commits")"

  echo "$filter"

  git filter-branch -f --commit-filter "$filter" $commit^..HEAD
}
