#! /usr/bin/env bash

alias got='git'
alias gut='git'
alias get='git'
alias gti='git'

alias g='tig'
alias t='tig'
alias b='tig blame'
alias y='tig stash'

alias v='git view-commit-head'
alias vv='git view-commit'
alias l='echo && git log-last && echo'
alias s='git status-short'
alias ss='git status'
alias d='git diff'
alias ds='git diff-staged'

alias rb='git_rebase_smart'
alias rr='git_recombine_smart'
alias rc='git_recommit_smart'
alias rt='git_squash_tmp_smart'
alias rf='git_last_tmp_to_fixup_smart'
alias rh='git_hoist_smart'
alias rn='git_rename_smart'
alias c='git_commit_tmp'
alias f='git_commit_fixup_smart'
alias u='git_unstage_smart'
alias a='git_add_smart'
alias r='git_remove_untracked_smart'

alias git-drop-smart='git_drop_smart'
alias git-redate='git_redate'

alias rb.='rb .'
alias rc.='rc .'
alias rt.='rt .'
alias rf.='rf .'
alias rh.='rh .'
alias c.='c .'
alias f.='f .'
alias u.='u .'
alias a.='a .'
alias r.='r .'

alias rb,='rb .'
alias rc,='rc .'
alias rt,='rt .'
alias rf,='rf .'
alias rh,='rh .'
alias c,='c .'
alias f,='f .'
alias u,='u .'
alias a,='a .'
alias r,='r .'

alias __exit_on_error__='local last=$?; test $last -ne 0 && return $last'

function __git_has_staged__ {
  # https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository
  # https://stackoverflow.com/a/2659808
  git update-index -q --ignore-submodules --refresh
  ! git diff-index --cached --quiet HEAD --ignore-submodules
}

function __git_has_modified__ {
  git update-index -q --ignore-submodules --refresh
  ! git diff-files --quiet --ignore-submodules
}

function __git_has_untracked__ {
  test -n "$(__git_untracked_list__)"
}

function __git_dirty__ {
  __git_has_staged__ || __git_has_modified__ || __git_has_untracked__
}

function __git_staged_list__ {
  git diff-index --cached --name-only -r --ignore-submodules HEAD
}

function __git_modified_list__ {
  git diff-files --name-only -r --ignore-submodules
}

function __git_untracked_list__ {
  git ls-files --others --exclude-standard --full-name -- "$(git root)"
}

function __git_stageable_list__ {
  __git_modified_list__
  __git_untracked_list__
}

function __git_find_oldest_tmp__ {
  git log --format="%h %s" -n 100 | while read line ; do
    if [[ "$line" =~ ^[[:alnum:]]+[[:space:]][[:digit:]]+$ ]]; then
      local last="$line"
    else
      echo "$last" | awk '{ print $1 }'
      break
    fi
  done
}

function __git_find_latest_tmp__ {
  local last="$(git log --format="%h %s" -n 1)"
  if [[ "$last" =~ ^[[:alnum:]]+[[:space:]][[:digit:]]+$ ]]; then
    echo "$last" | awk '{ print $1 }'
  fi
}

function __git_find_every_tmp__ {
  git log --format="%h %s" -n 100 | while read line ; do
    if [[ "$line" =~ ^[[:alnum:]]+[[:space:]][[:digit:]]+$ ]]; then
      echo "$line" | awk '{ print $1 }'
    fi
  done
}

function __git_show__ {
  git view-commit-head
  echo
}

function __git_log__ {
  git log-last
  echo
}

function __git_status__ {
  git -c color.status=always status
  echo
}

function __git_fixup_targets__ {
  # https://stackoverflow.com/a/29613573
  git log --format='%s' -n 100 | grep -P '^fixup!\s' | sed -r -e 's/^(fixup! )+//' | uniq | sed 's/[^^]/[&]/g; s/\^/\\^/g'
}

function __git_gt_commit__ {
  if [[ -z "$2" ]]; then
    return 0
  fi

  local distance_a="$(git rev-list --count "$1..HEAD")"
  local distance_b="$(git rev-list --count "$2..HEAD")"
  (("$distance_a" > "$distance_b"))
}

function __git_sort_commits__ {
  local input_array=("$@")
  local sorted_array=()
  for commit in "${input_array[@]}"; do
    local distance="$(git rev-list --count "$commit..HEAD")"
    sorted_array["$distance"]="$commit"
  done
  echo "${sorted_array[@]}"
}

function __git_most_distant_commit__ {
  local sorted_array=($(__git_sort_commits__ "$@"))
  echo "${sorted_array[-1]}"
}

function git_recommit_smart {
  if [[ "$1" == '.' ]]; then
    readarray -t paths <<< "$(__git_stageable_list__)"
  else
    paths=''
  fi

  echo
  for line in "${paths[@]}"; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add -f $(clr_yellow "$line")"
      git add -f "$(git root)/$line"
      __exit_on_error__
    fi
  done

  echo "$(clr_black_i $) git recommit"
  echo
  git commit --amend --quiet
  __exit_on_error__
  __git_show__
}

function git_rebase_smart {
  if [[ "$1" == "." ]]; then
    if [[ -z "$(__git_fixup_targets__)" ]]; then
      clr_yellow "nothing to do!"
      return 2
    fi

    readarray -t lines <<< "$(__git_fixup_targets__)"
    local commits=()
    for line in "${lines[@]}"; do
      local commit="$(git log --format="%h" -n1 --grep "^$line$")"
      if [[ -z "$commit" ]]; then
        clr_bg_red "cannot find commit matching $line"
        return 1
      fi
      commits+=("$commit")
    done

    local most_distant_commit="$(__git_most_distant_commit__ "${commits[@]}")"
    if [[ -z "$most_distant_commit" ]]; then
      clr_bg_red "something went wrong"
      return 1
    fi

    echo
    echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR="$(which true)"") git rebase -i $(clr_cyan "$most_distant_commit")^"
    echo
    GIT_SEQUENCE_EDITOR="$(which true)" git rebase -i "$most_distant_commit^"
    __exit_on_error__
    echo
  else
    local commit="$(gh)"

    if [[ -z "$commit" ]]; then
      clr_bg_blue "input was interrupted!"
      return 130
    fi

    echo
    echo "$(clr_black_i $) git rebase -i $(clr_cyan "$commit")^"
    echo
    git rebase -i "$commit^"
    __exit_on_error__
    echo
  fi
}

function git_commit_tmp {
  if ! __git_dirty__; then
    clr_yellow "nothing to do!"
    return 2
  fi

  echo
  readarray -t lines <<< "$(__git_stageable_list__)"
  for line in "${lines[@]}"; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add -f $(clr_yellow "$line")"
      git add -f "$(git root)/$line"
      __exit_on_error__
    fi
  done

  local last="$(git log --format='%B' -n 1 HEAD | sed -r -e 's/^(fixup! )+//' | rg '^[0-9]+$')"
  local next="1"
  if [[ -n "$last" ]]; then
    local next="$(expr "$last" + 1)"
  fi

  echo "$(clr_black_i $) git commit -m $(clr_cyan "$next")"
  echo
  git commit -m "$next" --quiet
  __exit_on_error__
  __git_show__
}

function git_commit_fixup_smart {
  if ! __git_dirty__; then
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == '.' ]]; then
    readarray -t paths <<< "$(__git_stageable_list__)"
  elif ! __git_has_staged__; then
    readarray -t paths <<< "$(gf)"
  else
    paths=''
  fi

  if ! __git_has_staged__ && [[ -z "${paths[@]}" ]]; then
    clr_bg_blue "nothing is staged and paths are not defined!"
    return 100
  fi

  if [[ "$1" == "." ]]; then
    local commit="HEAD"
  elif [[ -n "$1" ]]; then
    local commit="$1"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    clr_bg_blue "commit is not defined!"
    return 100
  fi

  echo
  for line in "${paths[@]}"; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add -f $(clr_yellow "$line")"
      git add -f "$(git root)/$line"
      __exit_on_error__
    fi
  done

  echo "$(clr_black_i $) git commit --fixup $(clr_cyan "$commit")"
  echo
  git commit --quiet --fixup $commit
  __exit_on_error__
  __git_show__
}

function git_unstage_smart {
  if ! __git_has_staged__; then
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == "." ]]; then
    readarray -t paths <<< "$(__git_staged_list__)"
  elif [[ -n "$1" ]]; then
    readarray -t paths <<< "$@"
  else
    readarray -t paths <<< "$(gf)"
  fi

  if [[ -z "${paths[@]}" ]]; then
    clr_bg_blue "paths are not defined!"
    return 100
  fi

  echo
  for line in "${paths[@]}"; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git unstage $(clr_green "$line")"
      git unstage "$(git root)/$line" > /dev/null
      __exit_on_error__
    fi
  done

  echo
  __git_status__
}

function git_add_smart {
  if ! __git_has_modified__; then
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == "." ]]; then
    readarray -t paths <<< "$(__git_stageable_list__)"
  elif [[ -n "$1" ]]; then
    readarray -t paths <<< "$@"
  else
    readarray -t paths <<< "$(gf)"
  fi

  if [[ -z "${paths[@]}" ]]; then
    clr_bg_blue "paths are not defined!"
    return 100
  fi

  echo
  for line in "${paths[@]}"; do
    if [[ -n "$line" ]]; then
      echo "$(clr_black_i $) git add -f $(clr_yellow "$line")"
      git add -f "$(git root)/$line"
      __exit_on_error__
    fi
  done

  echo
  __git_status__
}

function git_remove_untracked_smart {
  if ! __git_has_untracked__; then
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == '.' ]]; then
    readarray -t paths <<< "$(__git_untracked_list__)"
  else
    readarray -t paths <<< "$(__git_untracked_list__ | fzf --multi)"
  fi

  if [[ -z "${paths[@]}" ]]; then
    clr_bg_blue "paths are not defined!"
    return 100
  fi

  echo
  for line in "${paths[@]}"; do
    echo "$(clr_black_i $) gio trash -f \"$(clr_red_b "$line")\""
    gio trash -f "$(git root)/$line"
    __exit_on_error__
  done

  echo
  __git_status__
}

function git_squash_tmp_smart {
  if [[ "$1" == '.' ]]; then
    local commit="$(__git_find_oldest_tmp__)"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    clr_yellow "nothing to do!"
    return 2
  fi

  local last="$(__git_find_latest_tmp__)"
  if [[ "$commit" == "$last" ]]; then
    clr_yellow "nothing to do!"
    return 2
  fi

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-squash-tmp.js") git rebase -i $(clr_cyan "$commit")^"
  echo
  GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-squash-tmp.js" git rebase -i "$commit"^
  __exit_on_error__

  echo
  __git_show__
}

function git_last_tmp_to_fixup_smart {
  if __git_dirty__; then
    __git_status__
    clr_bg_red "cleanup project first!"
    return 3
  fi

  if [[ -z "$(__git_find_latest_tmp__)" ]]; then
    __git_log__
    clr_bg_red "last commit is not temporary!"
    return 4
  fi

  if [[ "$1" == "." ]]; then
    local commit="HEAD"
  elif [[ -n "$1" ]]; then
    local commit="$1"
  else
    local commit="$(gh)"
  fi

  if [[ -z "$commit" ]]; then
    clr_bg_blue "commit is not defined!"
    return 100
  fi

  echo
  echo "$(clr_black_i $) git uncommit"
  echo "$(clr_black_i $) git commit --fixup $(clr_cyan "$commit")"
  echo
  git uncommit && git commit --quiet --fixup "$commit"
  __exit_on_error__
  __git_show__
}

function git_hoist_smart {
  if [[ "$1" == "." && -z "$(__git_find_every_tmp__)" ]]; then
    clr_yellow "nothing to do!"
    return 2
  fi

  if [[ "$1" == "." ]]; then
    local commits=($(__git_find_every_tmp__))
  else
    local commits=($(gh))
  fi

  if [[ -z "${commits[@]}" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local most_distant_commit="$(__git_most_distant_commit__ "${commits[@]}")"

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-hoist.js") git rebase -i $(clr_cyan "$most_distant_commit")^"
  echo
  COMMITS="${commits[@]}" GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-hoist.js" git rebase -i "$most_distant_commit"^
  __exit_on_error__
  echo
}

function git_drop_smart {
  local commits="$(gh)"

  if [[ -z "$commits" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local last_commit="$(echo "$commits" | tail -n1)"

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-drop.js") git rebase -i $(clr_cyan "$last_commit")^"
  echo
  COMMITS="$commits" GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-drop.js" git rebase -i "$last_commit"^
  __exit_on_error__
  echo
}

function git_rename_smart {
  local commits="$(gh)"

  if [[ -z "$commits" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local last_commit="$(echo "$commits" | tail -n1)"

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-rename.js") git rebase -i $(clr_cyan "$last_commit")^"
  echo
  COMMITS="$commits" GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-rename.js" git rebase -i "$last_commit"^
  __exit_on_error__
  echo
}

function git_recombine_smart {
  local commits="$(gh)"

  if [[ -z "$commits" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local last_commit="$(echo "$commits" | tail -n1)"

  echo
  echo "$(clr_black_i $) $(clr_magenta "GIT_SEQUENCE_EDITOR=~/.bash-tools/rebase-recombine.js") git rebase -i $(clr_cyan "$last_commit")^"
  echo
  COMMITS="$commits" GIT_SEQUENCE_EDITOR="$HOME/.bash-tools/rebase-recombine.js" git rebase -i "$last_commit"^
  __exit_on_error__
  echo
}

function git_redate {
  local commit="$(gh)"

  if [[ -z "$commit" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local format="$(echo -e "author date\ncommit date" | fzf --preview "\
                  ([[ {1} == 'author' ]] \
                    && git log --format="%ad" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD \
                    || git log --format="%cd" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD) | sort -r")"

  if [[ -z "$format" ]]; then
    clr_bg_blue "input was interrupted!"
    return 130
  fi

  local commits="$(git log --format="%H" $commit^..HEAD)"
  local dates="$([[ "$format" == "author date" ]] \
                  && git log --format="%ad" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD | sort -r \
                  || git log --format="%cd" --date=format:'%Y-%m-%d %H:%M' $commit^..HEAD | sort -r)"

  local filter="$(node -e '
    const dateList = process.argv[1].split("\n")
    const commitList = process.argv[2].split("\n")

    let filter = ""
    for (let index = 0; index !== commitList.length; index++) {
      const date = dateList[index]
      const commit = commitList[index]
      filter += `
        ${index === 0 ? "if" : "elif"} [ $GIT_COMMIT = ${commit} ]; then
          GIT_AUTHOR_DATE="${date}"
          GIT_COMMITTER_DATE="${date}"
          git commit-tree "$@"`
    }
    filter += `
        else
          git commit-tree "$@"
        fi`
    console.info(filter)
  ' "$dates" "$commits")"

  echo "$filter"

  git filter-branch -f --commit-filter "$filter" $commit^..HEAD
}
